<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>https://foggy1.github.io/</link>
    <atom:link href="https://foggy1.github.iofeed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 31 Oct 2016 15:19:28 -0400</pubDate>
    <lastBuildDate>Mon, 31 Oct 2016 15:19:28 -0400</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Convention over Configuration... ish</title>
        <description>&lt;p&gt;“Should we just move our project to Node?”&lt;/p&gt;

&lt;p&gt;What I thought would be famous last words turned out to be one of the most satisfying days I had as a programmer.  At Dev Bootcamp, we were taught a very… Ruby-ish stack.  Javascript permeated our projects (with an emphasis on jQuery in phase 2 and React in phase 3), but the foundation of our projects was always one stacked on conventions and not configurations.&lt;/p&gt;

&lt;p&gt;Despite all of this, our app &lt;a href=&quot;http://state-matters.com&quot; target=&quot;_blank&quot;&gt;State Matters&lt;/a&gt; doesn’t require a &lt;strong&gt;single&lt;/strong&gt; trick out of Rails’ very, very large hat.  So why were we using Rails?  “Let’s timebox learning Node to two-and-a-half-hours”, says my overly persuasive teammate.  Despite being project lead (or perhaps because of it) I felt inclined to take the risk and slim down our project while taking advantage of new technology.  Two-and-a-half hours seemed reasonable.  Mind you we had five days to build this app from scratch and this was prime-time, day two.&lt;/p&gt;

&lt;h3 id=&quot;nine-hours-later&quot;&gt;Nine hours later.&lt;/h3&gt;

&lt;p&gt;Ok, ok, sorry.&lt;/p&gt;

&lt;h3 id=&quot;nine-irritating-hours-later&quot;&gt;Nine irritating hours later.&lt;/h3&gt;

&lt;p&gt;There we go.&lt;/p&gt;

&lt;p&gt;Despite some guidance from a friend from the Grace Hopper Academy, taking all of our React components out of Rails was proving to be a configuration nightmare.  What type of person knows the arcane wizardry required to include dependencies in the proper files &lt;strong&gt;manually?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I won’t harp too much on the pitfalls of the ‘convention over configuration’ mindset, but we were, at a minimum, inconveniently hamstrung by our reliance on Rails.  Eventually, though, we did figure out the minutiae of configuring Webpack and Express in Node.js (and it wasn’t all that hard) and were then able to copy over our react-rails components into vanilla React.js with literally no changes beyond exporting the components.&lt;/p&gt;

&lt;p&gt;The fact is that learning things on Ruby’s level of abstraction– from built-in enumerable methods all the way up to Rails, the ultimate in “no, let me get that for you” –proved &lt;strong&gt;really great&lt;/strong&gt; for us.  Sure, it gives you a slow start-up time on configuration-heavy technologies (read: &lt;em&gt;everything else&lt;/em&gt;), but it gave all of us something much more important: a point of reference.&lt;/p&gt;

&lt;p&gt;If you’re going to learn in an accelerated environment, now having been through it myself, it strikes me as obviously true that getting bogged down in configuration is a waste of your time.  You could, instead, be growing your skills overall, constantly exposing your ignorance and rising to new challenges, all while obtaining frames of reference for all kinds of different scopes of technology.  Sure, you’ll have to do a little more digging and memory refreshing when you have to set up that Express server or hear about how C allocates memory or something; but, and excuse the candidness, &lt;em&gt;you can &lt;strong&gt;do&lt;/strong&gt; shit&lt;/em&gt;.  You can still build whatever you want in the frameworks you’re comfortable with while you dig deep and learn the new stuff.&lt;/p&gt;

&lt;p&gt;The more I utilize the flexibility of Javascript and circle the skies eyeing all kinds of other frameworks, the more the ‘convention over configuration’ attitude bugs me.  But the whole entire reason my team and I were able to learn Node.js in a day and redeploy our projection was specifically because conventions helped us build a solid core of learning skills quickly, and now nothing is stopping us except time.&lt;/p&gt;

&lt;p&gt;Well, time and semi-colons.&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Oct 2016 20:00:00 -0400</pubDate>
        <link>https://foggy1.github.io/coding/dbc/rails/node/2016/10/26/Convention-and-Configuration.html</link>
        <guid isPermaLink="true">https://foggy1.github.io/coding/dbc/rails/node/2016/10/26/Convention-and-Configuration.html</guid>
        
        
        <category>Coding</category>
        
        <category>DBC</category>
        
        <category>Rails</category>
        
        <category>Node</category>
        
      </item>
    
      <item>
        <title>Troubleshooting Jekyll</title>
        <description>&lt;p&gt;After hours upon &lt;em&gt;hours&lt;/em&gt; of struggling with Jekyll, it looks like I’ve finally got the site working.  Initially, I had it working locally on my machine; unfortunately, getting something working &lt;strong&gt;locally&lt;/strong&gt; and getting something working in a way that, you know, actually funting &lt;em&gt;matters&lt;/em&gt; are apparently two completely different things!  I guess that’s a big lesson in programming learned.&lt;/p&gt;

&lt;p&gt;When I had that issue and no apparent issue in my code, I went straight to GitHub support since I had no idea where to even start troubleshooting a Jekyll build, particularly when the hard part, the code, was working.  Turns out I was having a simple relative path problem.  Originally, when I uploaded my code, links looked like this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/css&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;assets/css/main.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Except this is the &lt;em&gt;exact&lt;/em&gt; kind of thing that will work well locally, but not remotely.  When you give your link an “href” you’re giving it a place to look for a file.  But, even if you don’t know much about coding, it’s obvious that the path this href has isn’t an &lt;strong&gt;absolute&lt;/strong&gt; path: it’s just the end of a file path, obviously the location doesn’t &lt;em&gt;start&lt;/em&gt; with “assets”.  This is a &lt;strong&gt;relative&lt;/strong&gt; path; the question is, is it the &lt;em&gt;right&lt;/em&gt; relative path?  And the answer is, yes locally, no remotely.&lt;/p&gt;

&lt;p&gt;Locally, to test your site on Jekyll, you have to set up a Jekyll environment so you can run a Jekyll server.  That server runs out of the local directory, so when I tell it, “hey computer, go look for assets”, it does that from the server’s directory.  Incidentally, installing a local Jekyll environment can be fraught with a lot of nonsense: I’d suggest using &lt;a href=&quot;https://help.github.com/articles/setting-up-your-github-pages-site-locally-with-jekyll/&quot;&gt;github’s own guide&lt;/a&gt;.  Other guides that people have on their blogs are missing key dependencies and are otherwise woefully out of date.  Bundler is your friend.&lt;/p&gt;

&lt;p&gt;Anyway, pushing that code to GitHub led to one major problem: the directory structure is &lt;em&gt;different&lt;/em&gt;. If you run a normal GitHub user site, the site is located at [username].github.io and runs right out of a directory with an identical name.  In that case, calls to “assets/css/main.css” would totally work.  But &lt;strong&gt;Project Pages&lt;/strong&gt; are located at [username].github.io&lt;strong&gt;/[Project’s Directory Name]&lt;/strong&gt;.  Since I’m running Jekyll on GitHub out of a “blog” directory, my site is located at “foggy1.github.io/blog”.  That’s all well and good, but because of how GitHub pages works, calls to “assets/css/main.css” will go right to the root: it was looking for “foggy1.github.io/assets/css/main.css”.  Not uh… not the right result.  There needs to be a “/blog” in there, lest I move all my files to the root directory which is really not the right way to do things in this case.   Repositories will cross over, things will be a nightmare to test, etc. etc.&lt;/p&gt;

&lt;p&gt;Without going bonkers explaining all the particular problems that might arise from how I might decide to deal with the relative path problem, I went with this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/css&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;
 { { site.baseurl } }/assets/css/main.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;[&lt;em&gt;Note: no spaces between the same-facing brackets in the real code&lt;/em&gt;]. Jekyll keeps its most important info in a config file, including but not limited to things like your site’s name, a description of the site, the markdown interpreter of your choice, and something known as a &lt;strong&gt;baseurl&lt;/strong&gt;.  When I stumbled upon &lt;a href=&quot;https://byparker.com/blog/2014/clearing-up-confusion-around-baseurl/&quot;&gt;this succinct and helpful explanation&lt;/a&gt; I realized I could help myself to the baseurl attribute of my site to prepend the calls to CSS assets, javascript er… scripts, and ….. well, frigging &lt;em&gt;links&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Yes, it took longer than I’d like to admit to come to the simple realization that “foggy1.github.io/blog” (the homepage) should link to “foggy1.github.io/blog/[a post or a page]” and vice versa.  Even a single dropped “/blog” prepended to a single HTML link or page permalink would mean the whole site wasn’t really working right.  Helping myself to the baseurl attribute allowed me to keep things consistent as well as normalize how things fit together locally as well as remotely.&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Jul 2016 21:10:00 -0400</pubDate>
        <link>https://foggy1.github.io/jekyll/coding/2016/07/17/Testing-This-Damn-Thing.html</link>
        <guid isPermaLink="true">https://foggy1.github.io/jekyll/coding/2016/07/17/Testing-This-Damn-Thing.html</guid>
        
        
        <category>Jekyll</category>
        
        <category>Coding</category>
        
      </item>
    
  </channel>
</rss>
